!                   *********************
                    SUBROUTINE POINT_GAIA
!                   *********************
!
!
!***********************************************************************
! GAIA
!***********************************************************************
!
!>@brief Allocates structures.
!
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
      USE BIEF
      USE DECLARATIONS_GAIA
      USE DECLARATIONS_SPECIAL
      IMPLICIT NONE


      ! 2/ LOCAL VARIABLES
      ! ------------------
      INTEGER :: I,K,NTR,IELM0,IELM1,IELBT,IELM0_SUB,CHECK_NVAR
      INTEGER :: CFG(2),CFGBOR(2)

!-----------------------------------------------------------------------
!
!-----------------------------------------------------------------------

      WRITE(LU,12)

      ! ************************************** !
      ! I - DISCRETISATION AND TYPE OF STORAGE !
      ! ************************************** !
      ! IELMT, IELMH_GAI AND IELMU_GAI HARD-CODED IN LECDON
      IELM0     = 10
      IELM1     = 11
      IELBT     = IELBOR(IELMT,1)
      IELM0_SUB = 10*(IELMT/10)

      CFG(1)    = OPTASS
      CFG(2)    = PRODUC
      CFGBOR(1) = 1 ! CFG IMPOSED FOR BOUNDARY MATRICES
      CFGBOR(2) = 1 ! CFG IMPOSED FOR BOUNDARY MATRICES

      SOLSYS_GAI = 0
      SAVE_UCONV => NULL()
      SAVE_VCONV => NULL()

      IF(VF) EQUA(1:15)='SAINT-VENANT VF'

      ! ******************************************* !
      ! II - ALLOCATES THE MESH STRUCTURE           !
      ! ******************************************* !
      IF(.NOT.(ASSOCIATED(MESH%X))) THEN
        CALL ALMESH(MESH,'MESH_S',IELMT,SPHERI,CFG,
     &           GAI_FILES(GAIGEO)%FMT,GAI_FILES(GAIGEO)%LU,EQUA,
     &           0)
      END IF

      IKLE  => MESH%IKLE
      X     => MESH%X%R
      Y     => MESH%Y%R
      NELEM => MESH%NELEM
      NELMAX=> MESH%NELMAX
      NPTFR => MESH%NPTFR
      NPTFRX=> MESH%NPTFRX
      TYPELM=> MESH%TYPELM
      NPOIN => MESH%NPOIN
      NPMAX => MESH%NPMAX
      MXPTVS=> MESH%MXPTVS
      MXELVS=> MESH%MXELVS
      LV    => MESH%LV


      ! ******************** !
      ! III - REAL ARRAYS    !
      ! ******************** !
      CALL BIEF_ALLVEC(1,S     , 'S     ', 0    , 1, 1,MESH) ! VOID STRUCTURE
      CALL BIEF_ALLVEC(1,E     , 'E     ', IELMT, 1, 2,MESH) ! BED EVOLUTION (KG/M2)
      CALL BIEF_ALLVEC(1,Z     , 'ZCLIP ', IELMT, 1, 2,MESH) ! CLIPPED FREE SURFACE
      CALL BIEF_ALLVEC(1,ESOMT , 'ESOMT ', IELMT, 1, 2,MESH) ! VARIABLES E SUMMED UP
      CALL BIEF_ALLVEC(1,CUMBE , 'CUMBE ', IELMT, 1, 2,MESH) ! VARIABLES BE SUMMED UP
      CALL BIEF_ALLVEC(1,EMAX  , 'EMAX  ', IELMT, 1, 2,MESH) ! VARIABLES E SUMMED UP
      CALL BIEF_ALLVEC(1,EVOL_MB,'EVL_MB', IELMT, 1, 2,MESH) ! TOTAL MASS EVOLUTION DUE TO BEDLOAD
      CALL BIEF_ALLVEC(1,EVOL_MS,'EVL_MS', IELMT, 1, 2,MESH) ! TOTAL MASS EVOLUTION DUE TO SUSPENSION
      CALL BIEF_ALLVEC(1,EVOL_MC,'EVL_MC', IELMT, 1, 2,MESH) ! TOTAL MASS EVOLUTION DUE TO CONSOLIDATION
      CALL BIEF_ALLVEC(1,EVOL_MM,'EVL_MM', IELMT, 1, 2,MESH) ! TOTAL MASS EVOLUTION DUE TO SLIDING
      CALL BIEF_ALLVEC(1,Q     , 'QCLIP ', IELMT, 1, 2,MESH) ! FLOWRATE BASED ON CLIPPED HN
      CALL BIEF_ALLVEC(1,QU    , 'QUCLIP', IELMT, 1, 2,MESH) ! X FLOWRATE BASED ON CLIPPED HN
      CALL BIEF_ALLVEC(1,QV    , 'QVCLIP', IELMT, 1, 2,MESH) ! Y FLOWRATE BASED ON CLIPPED HN
      CALL BIEF_ALLVEC(1,U2D   , 'UCLIP ', IELMT, 1, 2,MESH) ! X VELOCITY BASED ON CLIPPED HN
      CALL BIEF_ALLVEC(1,V2D   , 'VCLIP ', IELMT, 1, 2,MESH) ! Y VELOCITY BASED ON CLIPPED HN
      CALL BIEF_ALLVEC(1,THETAC, 'THETAC', IELMT, 1, 2,MESH) ! CURRENT DIRECTION
      CALL BIEF_ALLVEC(1,QS    , 'QS    ', IELMT, 1, 2,MESH) ! TRANSPORT RATE
      CALL BIEF_ALLVEC(1,QSX   , 'QSX   ', IELMT, 1, 2,MESH) ! X TRANSPORT RATE
      CALL BIEF_ALLVEC(1,QSY   , 'QSY   ', IELMT, 1, 2,MESH) ! Y TRANSPORT RATE
      CALL BIEF_ALLVEC(1,QS_C  , 'QS_C  ', IELMT, 1, 2,MESH) ! BEDLOAD RATE
      CALL BIEF_ALLVEC(1,QSXC  , 'QSXC  ', IELMT, 1, 2,MESH) ! X BEDLOAD RATE
      CALL BIEF_ALLVEC(1,QSYC  , 'QSYC  ', IELMT, 1, 2,MESH) ! Y BEDLOAD RATE
      CALL BIEF_ALLVEC(1,HIDING, 'HIDING', IELMT, 1, 2,MESH) ! HIDING FACTOR
      CALL BIEF_ALLVEC(1,ZF    , 'ZF    ', IELMT, 1, 2,MESH) ! BED ELEVATIONS
      CALL BIEF_ALLVEC(1,ZR    , 'ZR    ', IELMT, 1, 2,MESH) ! NON-ERODABLE BED ELEVATIONS
      CALL BIEF_ALLVEC(1,ZRL   , 'ZRL   ', IELMT, 1, 2,MESH) ! REFERENCE LEVEL FOR NESTOR
      CALL BIEF_ALLVEC(1,RADSEC, 'RADSEC', IELMT, 1, 2,MESH) ! RADIUS SECONDARY CURRENTS
      CALL BIEF_ALLVEC(1,ZREF  , 'ZREF  ', IELMT, 1, 2,MESH) ! REFERENCE ELEVATION
      CALL BIEF_ALLVEC(1,COEFPN, 'COEFPN', IELMT, 1, 2,MESH) ! SLOPE EFFECT
      CALL BIEF_ALLVEC(1,COEFCR, 'COEFCR', IELMT, 1, 2,MESH) ! SLOPE EFFECT CRITICAL SHIELDS      
      CALL BIEF_ALLVEC(1,CF    , 'CF    ', IELMT, 1, 2,MESH) ! ADIMENSIONAL FRICTION
      CALL BIEF_ALLVEC(1,TOB   , 'TOB   ', IELMT, 1, 2,MESH) ! CURRENT SHEAR STRESS
      CALL BIEF_ALLVEC(1,TAUP  , 'TAUP  ', IELMT, 1, 2,MESH) ! SHEAR STRESS MODIFIED BY SKIN FRICTION
      CALL BIEF_ALLVEC(1,TOBW  , 'TOBW  ', IELMT, 1, 2,MESH) ! WAVE SHEAR STRESS
      CALL BIEF_ALLVEC(1,TOBCW_MEAN, 'TOBCW_MEAN', IELMT, 1, 2,MESH) ! SHEAR STRESS
      CALL BIEF_ALLVEC(1,TOBCW_MAX, 'TOBCW_MAX', IELMT, 1, 2,MESH) ! SHEAR STRESS
      CALL BIEF_ALLVEC(1,MU    , 'MU    ', IELMT, 1, 2,MESH) ! SKIN FRICTION
      CALL BIEF_ALLVEC(1,KSP   , 'KSP   ', IELMT, 1, 2,MESH) ! SKIN ROUGHNESS
      CALL BIEF_ALLVEC(1,KS    , 'KS    ', IELMT, 1, 2,MESH) ! TOTAL ROUGHNESS
      CALL BIEF_ALLVEC(1,KSR   , 'KSR   ', IELMT, 1, 2,MESH) ! RIPPLE INDUCED ROUGHNESS
      CALL BIEF_ALLVEC(1,THETAW, 'THETAW', IELMT, 1, 2,MESH) ! WAVE VARIABLE
      CALL BIEF_ALLVEC(1,FW    , 'FW    ', IELMT, 1, 2,MESH) ! WAVE VARIABLE
      CALL BIEF_ALLVEC(1,UW    , 'UW    ', IELMT, 1, 2,MESH) ! WAVE VARIABLE
      CALL BIEF_ALLVEC(1,HW    , 'HW    ', IELMT, 1, 2,MESH)
      CALL BIEF_ALLVEC(1,TW    , 'TW    ', IELMT, 1, 2,MESH)
      CALL BIEF_ALLVEC(1,FLUERDH, 'FLERDH', IELMT, 1, 2,MESH) ! EROSION FLUX DIVIDE BY THE WATER DEPTH
      CALL BIEF_ALLVEC(1,FLUER_ADV, 'FLERAD', IELMT, 1, 2,MESH) ! EROSION FLUX USED IN THE ADVECTION SCHEME
      CALL OV('X=0     ', X=FLUER_ADV%R, DIM1=MESH%NPOIN)
      CALL BIEF_ALLVEC(1,FLUDPT_ADV, 'FLDPAD', IELMT, 1, 2,MESH) ! DEPOSITION FLUX USED IN THE ADVECTION SCHEME
      CALL OV('X=0     ', X=FLUDPT_ADV%R, DIM1=MESH%NPOIN)
      CALL BIEF_ALLVEC(1,FLUERDH, 'FLERDH', IELMT, 1, 2,MESH) ! EROSION FLUX DIVIDE BY THE WATER DEPTH
      CALL BIEF_ALLVEC(1,ACLADM, 'ACLADM', IELMT, 1, 2,MESH) ! MEAN DIAMETER IN ACTIVE LAYER
      CALL BIEF_ALLVEC(1,UNLADM, 'UNLADM', IELMT, 1, 2,MESH) ! MEAN DIAMETER IN 2ND LAYER
      CALL BIEF_ALLVEC(1,HCPL  , 'HCPL  ', IELMT, 1, 2,MESH) ! WATER DEPTH SAVED FOR CONSTANT FLOW DISCHARGE
      CALL BIEF_ALLVEC(1,ECPL  , 'ECPL  ', IELMT, 1, 2,MESH) ! EVOLUTION SAVED FOR CONSTANT FLOW DISCHARGE
      CALL BIEF_ALLVEC(1,ELAY  , 'ELAY  ', IELMT, 1, 2,MESH) ! ACTIVE LAYER THICKNESS
      CALL BIEF_ALLVEC(1,ESTRAT, 'ESTRAT', IELMT, 1, 2,MESH) ! 2ND LAYER THICKNESS
      CALL BIEF_ALLVEC(1,KX    , 'KX    ', IELMT, 1, 1,MESH)
      CALL BIEF_ALLVEC(1,KY    , 'KY    ', IELMT, 1, 1,MESH)
      CALL BIEF_ALLVEC(1,KZ    , 'KZ    ', IELMT, 1, 1,MESH)
      CALL BIEF_ALLVEC(1,UCONV_GAI, 'UCONV ', IELMT, 1, 1,MESH)
      CALL BIEF_ALLVEC(1,VCONV_GAI, 'VCONV ', IELMT, 1, 1,MESH)
      CONV_GAI_POINTER = .FALSE.
      CALL BIEF_ALLVEC(1,UNORM , 'UNORM ', IELMT, 1, 2,MESH)
      CALL BIEF_ALLVEC(1,MASKB , 'MASKB ', IELM0, 1, 2,MESH)
      CALL BIEF_ALLVEC(1,MASK  , 'MASK  ', IELBT, 1, 2,MESH)
      CALL BIEF_ALLVEC(1,AFBOR , 'AFBOR ', IELBT, 1, 1,MESH)
      CALL BIEF_ALLVEC(1,BFBOR , 'BFBOR ', IELBT, 1, 1,MESH)
      CALL BIEF_ALLVEC(1,FLBOR , 'FLBOR ', IELBT, 1, 1,MESH)
      CALL BIEF_ALLVEC(1,Q2BOR , 'Q2BOR ', IELBT, 1, 1,MESH)
!     BOUNDARY FLUX FOR CALL TO CVDFTR
      CALL BIEF_ALLVEC(1,FLBOR_GAI , 'FLBORS', IELBT, 1, 1,MESH)
      CALL BIEF_ALLVEC(1,FLBORTRA  , 'FLBTRA', IELBT, 1, 1,MESH)
!
!     MAK ADDITION
      CALL BIEF_ALLVEC(1,HN    , 'HN    ', IELMH_GAI, 1, 2,MESH) ! CLIPPED WATER DEPTH
      CALL BIEF_ALLVEC(1,HN_GAI, 'HN_GAI', IELMH_GAI, 1, 2,MESH) ! CLIPPED WATER DEPTH SENT TO T2D
      CALL OV('X=0     ', X=HN_GAI%R, DIM1=MESH%NPOIN)
      CALL BIEF_ALLVEC(1,HPROP , 'HPROP ', IELMH_GAI, 1, 1,MESH)
      CALL BIEF_ALLVEC(1,VOLU2D, 'VOLU2D', IELMH_GAI, 1, 1,MESH)
      CALL BIEF_ALLVEC(1,V2DPAR, 'V2DPAR', IELMH_GAI, 1, 1,MESH)
      CALL BIEF_ALLVEC(1,UNSV2D, 'UNSV2D', IELMH_GAI, 1, 1,MESH)
      CALL BIEF_ALLVEC(1,MPM_ARAY,'MPMARAY', IELMT, 1, 2,MESH)   ! MPM Array
      CALL BIEF_ALLVEC(1,FLULIM_GAI,'FLULIM' ,MESH%NSEG,1,0,MESH)
!
      IF(MSK) THEN
        CALL BIEF_ALLVEC(1,MASKEL,'MASKEL', IELM0 , 1 , 2 ,MESH)
        CALL BIEF_ALLVEC(1,MSKTMP,'MSKTMP', IELM0 , 1 , 2 ,MESH)
        CALL BIEF_ALLVEC(1,MASKPT,'MASKPT', IELMT , 1 , 2 ,MESH)
      ELSE
        CALL BIEF_ALLVEC(1,MASKEL,'MASKEL', 0 , 1 , 0 ,MESH)
        CALL BIEF_ALLVEC(1,MSKTMP,'MSKTMP', 0 , 1 , 0 ,MESH)
        CALL BIEF_ALLVEC(1,MASKPT,'MASKPT', 0 , 1 , 0 ,MESH)
      ENDIF
!
!     FOR MIXED SEDIMENTS : chec if ms_sable and ms_vase
!     are necessary and change condition in cse
!
      IF(SEDCO(1).OR.SEDCO(2)) THEN
! CV V6.2: replacement of NCOUCH_TASS in NOMBLAY
!
        CALL BIEF_ALLVEC(1,MS_SABLE   ,'MSSABL',
     &                   IELMT,NOMBLAY,2,MESH)
        CALL BIEF_ALLVEC(1,MS_VASE    ,'MSVASE',
     &                   IELMT,NOMBLAY,2,MESH)
      ELSE
        CALL BIEF_ALLVEC(1,MS_SABLE   ,'MSSABL',0,1,0,MESH)
        CALL BIEF_ALLVEC(1,MS_VASE    ,'MSVASE',0,1,0,MESH)
      ENDIF
!... END MODIF cv
      ! *********************** !
      ! IV - INTEGER ARRAYS     ! (_IMP_)
      ! *********************** !
      CALL BIEF_ALLVEC(2, LIEBOR, 'LIEBOR', IELBOR(IELM1,1), 1, 1,MESH)
      CALL BIEF_ALLVEC(2, LIQBOR, 'LIQBOR', IELBOR(IELM1,1), 1, 1,MESH)
      CALL BIEF_ALLVEC(2, LIMTEC, 'LIMTEC', IELBOR(IELM1,1), 1, 1,MESH)
      CALL BIEF_ALLVEC(2, NUMLIQ, 'NUMLIQ', IELBOR(IELM1,1), 1, 1,MESH)
      CALL BIEF_ALLVEC(2, CLT   , 'CLT   ', IELBOR(IELMT,1), 1, 1,MESH)
      CALL BIEF_ALLVEC(2, CLU   , 'CLU   ', IELBOR(IELMT,1), 1, 1,MESH)
      CALL BIEF_ALLVEC(2, CLV   , 'CLV   ', IELBOR(IELMT,1), 1, 1,MESH)
      CALL BIEF_ALLVEC(2, LIMDIF, 'LIMDIF', IELBOR(IELMT,1), 1, 1,MESH)
      CALL BIEF_ALLVEC(2, LIHBOR, 'LIHBOR', IELBOR(IELMT,1), 1, 1,MESH)
      CALL BIEF_ALLVEC(2, BOUNDARY_COLOUR,
     &                       'BNDCOL', IELBOR(IELMT,1), 1, 1,MESH)
      CALL BIEF_ALLVEC(2, LIMPRO, 'LIMPRO', IELBOR(IELMT,1), 6, 1,MESH)
      CALL BIEF_ALLVEC(2, IT1   , 'IT1   ', IELM1          , 1, 2,MESH)
      CALL BIEF_ALLVEC(2, IT2   , 'IT2   ', IELM1          , 1, 2,MESH)
      CALL BIEF_ALLVEC(2, IT3   , 'IT3   ', IELM1          , 1, 2,MESH)
      CALL BIEF_ALLVEC(2, IT4   , 'IT4   ', IELM1          , 1, 2,MESH)
! NUMBER OF LAYERS
      CALL BIEF_ALLVEC(2, NLAYER, 'NLAYE ', IELMT          , 1, 2,MESH)

      IF(VF) THEN
        CALL BIEF_ALLVEC(2,BREACH,'BREACH',IELM1,1,2,MESH)
      ELSE
        CALL BIEF_ALLVEC(2,BREACH,'BREACH',0,1,0,MESH)
      ENDIF

      IF(MSK) THEN
        CALL BIEF_ALLVEC(2,IFAMAS,'IFAMAS',
     &                   IELM0,BIEF_NBFEL(IELM0,MESH),1,MESH)
      ELSE
        CALL BIEF_ALLVEC(2,IFAMAS,'IFAMAS',0,1,0,MESH)
      ENDIF

      ! ******************* !
      ! V - BLOCK OF ARRAYS !
      ! ******************* !
      ALLOCATE(AVAIL(NPOIN,NOMBLAY,NSICLA)) ! FRACTION OF EACH CLASS FOR EACH LAYER
      ALLOCATE(ES(NPOIN,NOMBLAY))           ! THICKNESS OF EACH CLASS
      ALLOCATE(M2T(NSICLA,NPOIN))           ! CONVERSION MASS TO THICKNESS
      ALLOCATE(MPA2T(NSICLA))         ! CONVERSION MASS PER AREA TO THICKNESS
!
      ALLOCATE(IVIDE(NPOIN,NOMBLAY+1)) ! FRACTION OF EACH CLASS FOR EACH LAYER
!
      ALLOCATE(SANFRA(NPOIN)) ! SAND FRACTION CONTENT FOR WILCOCK & CROWE TRANSPORT FORMULA
!
!     FOR ARTELIA BED MODEL
!
      ALLOCATE(RATIO_MUD_SAND(NOMBLAY,NPOIN)) ! MUD/SAND RATIO
      ALLOCATE(MASS_MUD(NMUD,NOMBLAY,NPOIN)) ! FRACTION OF EACH CLASS FOR EACH LAYER
      ALLOCATE(MASS_SAND(MAX(NSAND,1),NOMBLAY,NPOIN)) ! FRACTION OF EACH CLASS FOR EACH LAYER
      MASS_SAND = 0.D0
      MASS_MUD = 0.D0
      ALLOCATE(MASS_MUD_TOT(NOMBLAY,NPOIN))
      ALLOCATE(MASS_SAND_TOT(NOMBLAY,NPOIN))
      ALLOCATE(MASS_MIX_TOT(NOMBLAY,NPOIN))
      MASS_SAND_TOT = 0.D0
      MASS_MUD_TOT = 0.D0
      MASS_MIX_TOT = 0.D0
      ALLOCATE(RATIO_SAND(MAX(NSAND,1),NOMBLAY,NPOIN))
      ALLOCATE(RATIO_MUD(MAX(NMUD,1),NOMBLAY,NPOIN))
      ALLOCATE(TOCE_SAND(MAX(NSAND,1),NPOIN))
      ALLOCATE(TOCE_MUD(NOMBLAY,NPOIN))
      ALLOCATE(CONC_MUD(NOMBLAY,NPOIN))
      ALLOCATE(TRANS_MASS(NOMBLAY,NPOIN))
      ALLOCATE(PARTHENIADES(NOMBLAY,NPOIN))
! ? ALLOCATE ONLY IF BED_MODEL = 1?
      ALLOCATE(QER_MUD(MAX(NMUD,1)))
      ALLOCATE(QER_SAND(MAX(NSAND,1)))
      ALLOCATE(TIME(MAX(NSAND,1)))
      ALLOCATE(TOCE_MIX(MAX(NSAND,1),NOMBLAY,NPOIN))
      ALLOCATE(CAE_ILAY(MAX(NSAND,1),NOMBLAY,NPOIN))
      ALLOCATE(QE_MOY(MAX(NSAND,1)))
      ALLOCATE(FLUER_PUR_MUD(MAX(NSAND,1),NPOIN))
      ALLOCATE(FLUER_PUR_SAND(MAX(NSAND,1),NPOIN))
      ALLOCATE(FLUER_MIX(MAX(NSAND,1),NPOIN))
      ALLOCATE(CONC_MUD_ACTIV_TEMPO(NPOIN))
      ALLOCATE(MASS_MUD_ACTIV_TEMPO(NPOIN))
      ALLOCATE(MASS_SAND_ACTIVE_LAYER(NPOIN))
      ALLOCATE(MASS_SAND_MASKED(NPOIN))
      ALLOCATE(EVCL_M_TOT_SAND(NPOIN))
      ALLOCATE(RATIO_EVOL_TOT_SAND(NPOIN))
      ALLOCATE(FLUX_MASS_MUD(NMUD,NOMBLAY,NPOIN))
      ALLOCATE(FLUX_MASS_MUD_TOT(NOMBLAY,NPOIN))
      ALLOCATE(FLUX_MASS_SAND(MAX(NSAND,1),NOMBLAY,NPOIN))
      ALLOCATE(NUM_TRANSF(NPOIN))
      ALLOCATE(FLUX_NEG_MUD_ACTIV_LAYER(NMUD,NPOIN))
      ALLOCATE(FLUX_NEG_SAND_ACTIV_LAYER(MAX(NSAND,1),NPOIN))
      ALLOCATE(FLUX_POS_MUD_ACTIV_LAYER(NMUD,NOMBLAY,NPOIN))
      ALLOCATE(FLUX_POS_SAND_ACTIV_LAYER(MAX(NSAND,1),NOMBLAY,NPOIN))
! ?
      IF(BILMA) THEN
        ALLOCATE(BEDLOAD_B_FLUX(MAXFRO,NSICLA))
        ALLOCATE(SUMBEDLOAD_B(MAXFRO,NSICLA))
      ENDIF
      IF(BILMA.OR.VSMTYPE==1) THEN
        ALLOCATE(MCUMUCLA(NSICLA))
      ENDIF
!
      CALL ALLBLO(MASKTR, 'MASKTR') ! MASK OF THE BOUNDARY CONDITIONS
      CALL ALLBLO(EBOR  , 'EBOR  ') ! BOUNDARY CONDITIONS
      CALL ALLBLO(QBOR  , 'QBOR  ') ! BOUNDARY CONDITIONS
      CALL ALLBLO(RATIOS  , 'RATIOS') ! MASS FRACTION OF EACH CLASS OF SAND
      CALL ALLBLO(RATIOM  , 'RATIOM') ! MASS FRACTION OF EACH CLASS OF MUD
      CALL ALLBLO(LAYTHI, 'LAYTHI') ! LAYER THICKNESSES
      CALL ALLBLO(LAYCONC, 'LAYCONC') ! MUD CONCENTRATION IN THE LAYERS
      CALL ALLBLO(MASS_S , 'MASS_S') ! MASS OF EACH CLASS OF SAND
      CALL ALLBLO(MASS_M , 'MASS_M') ! MASS OF EACH CLASS OF MUD
      CALL ALLBLO(MTRANSFER, 'MTRANS') ! MASS TRANSFER FOR CONSOLIDATION BETWEEN LAYERS
      CALL ALLBLO(TOCEMUD, 'TOCEMU') ! CRITICAL EROSION SHEAR STRESS OF THE MUD
      CALL ALLBLO(PARTHE, 'PARTHE') ! PARTHENIADES EROSION COEFFICIENT
!
      CALL ALLBLO(QSCL  , 'QSCL  ') ! TRANSPORT RATE FOR EACH CLASS
      CALL ALLBLO(QSCL_C, 'QSCL_C') ! BEDLOAD TRANSPORT RATE FOR EACH CLASS
      CALL ALLBLO(QSCLXC, 'QSCLXC') ! BEDLOAD TRANSPORT RATE FOR EACH CLASS ALONG X
      CALL ALLBLO(QSCLYC, 'QSCLYC') ! BEDLOAD TRANSPORT RATE FOR EACH CLASS ALONG Y
      CALL ALLBLO(MUDB  , 'MUDB  ') ! MASS OF MUD IN BEDLOAD ADDED IN SUSPENSION
      CALL ALLBLO(F_MUDB, 'F_MUDB') ! FLUX OF MUD IN BEDLOAD ADDED IN SUSPENSION
      CALL ALLBLO(ZFCL_C, 'ZFCL_C') ! EVOLUTION FOR EACH CLASS DUE TO BEDLOAD TRANSPORT
      CALL ALLBLO(EVCL_MB, 'EVC_MB') ! MASS EVOLUTION FOR EACH CLASS DUE TO BEDLOAD TRANSPORT
      CALL ALLBLO(EVCL_MS, 'EVC_MS') ! MASS EVOLUTION FOR EACH CLASS DUE TO BEDLOAD TRANSPORT
!
      CALL ALLBLO(QSCL_S, 'QSCL_S') ! SUSPENDED TRANSPORT RATE FOR EACH CLASS
      CALL ALLBLO(FLUDP , 'FLUDP ') ! DEPOSITION FLUX
      CALL ALLBLO(FLUDPT, 'FLUDPT') ! DEPOSITION FLUX FOR IMPLICITATION
      CALL ALLBLO(FLUER , 'FLUER ') ! EROSION FLUX
      CALL ALLBLO(FLUERT, 'FLUERT') ! EROSION FLUX FOR IMPLICITATION
!
      CALL ALLBLO(ZFCL_MS, 'ZFCL_MS') ! EVOLUTION FOR EACH CLASS DUE TO SLOPING BED EFFECTS
      CALL ALLBLO(CALFA_CL, 'CALFA ') ! CALFA FOR EACH CLASS
      CALL ALLBLO(SALFA_CL, 'SALFA ') ! SALFA FOR EACH CLASS
!
      CALL ALLBLO(CSTAEQ , 'CSTAEQ ') !
      CALL ALLBLO(RATIO_TOCE  , 'RATIO_TOCE') !
      CALL ALLBLO(CSRATIO , 'CSRATIO') !
!
      CALL BIEF_ALLVEC_IN_BLOCK(CSTAEQ,NSICLA,1,'CSTAEQ',IELMT,1,2,MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(CSRATIO,NSICLA,1,'CSRATIO',
     &       IELMT,1,2,MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(RATIO_TOCE,
     &                             NSICLA,1,'RATIO_TOCE',IELMT,1,2,MESH)
!
      CALL BIEF_ALLVEC_IN_BLOCK(MASKTR,5     ,1,'MSKTR ',IELBT,1,2,MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(EBOR  ,NSICLA,1,'EBOR  ',IELBT,1,2,MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(QBOR  ,NSICLA,1,'QBOR  ',IELBT,1,2,MESH)
!
!     V6P2 (JMH) FLUXES AT BOUNDARY FOR EVERY CLASS
!
      CALL ALLBLO(FLBCLA,'FLBCLA')
      CALL BIEF_ALLVEC_IN_BLOCK(FLBCLA,NSICLA,1,'FLBC  ',IELBT,1,2,MESH)
!
      CALL BIEF_ALLVEC_IN_BLOCK(RATIOS,NOMBLAY*NSAND,
     &                          1,'RATIOS',IELMT,1,2,MESH)
!
      CALL BIEF_ALLVEC_IN_BLOCK(RATIOM,NOMBLAY*NMUD,
     &                          1,'RATIOM',IELMT,1,2,MESH)
!
!     LAYTHI ALLOCATED WITH SIZE 0 AND POINTING TO RELEVANT SECTIONS OF ES
!
      CALL BIEF_ALLVEC_IN_BLOCK(LAYTHI,NOMBLAY,1,'LAYTHI',0,1,0,MESH)
      DO K=1,NOMBLAY
        DEALLOCATE(LAYTHI%ADR(K)%P%R)
        LAYTHI%ADR(K)%P%R=>ES(1:NPOIN,K)
        LAYTHI%ADR(K)%P%MAXDIM1=NPOIN
        LAYTHI%ADR(K)%P%DIM1=NPOIN
      ENDDO
!
!     LAYCONC ALLOCATED WITH SIZE 0 AND POINTING TO CONC_MUD
!
      CALL BIEF_ALLVEC_IN_BLOCK(LAYCONC,NOMBLAY,1,'LAYCONC',
     &                          IELMT,1,2,MESH)
!
!     MASS_S
!
      CALL BIEF_ALLVEC_IN_BLOCK(MASS_S,NOMBLAY*NSAND,
     &                          1,'MASS_S',IELMT,1,2,MESH)
!
!     MASS_M
!
      CALL BIEF_ALLVEC_IN_BLOCK(MASS_M,NOMBLAY*NMUD,
     &                          1,'MASS_M',IELMT,1,2,MESH)
!
!     MTRANSFER ALLOCATED WITH SIZE 0 AND POINTING TO TRANSF_MASS
!
      CALL BIEF_ALLVEC_IN_BLOCK(MTRANSFER,NOMBLAY,1,'MTRANS',
     &                          IELMT,1,2,MESH)
!
!     TOCEMUD ALLOCATED WITH SIZE 0 AND POINTING TO TOCE_MUD
!
      CALL BIEF_ALLVEC_IN_BLOCK(TOCEMUD,NOMBLAY,1,'TOCE_M',
     &                          IELMT,1,2,MESH)
!
!     PARTHE ALLOCATED WITH SIZE 0 AND POINTING TO PARTHENIADES
!
      CALL BIEF_ALLVEC_IN_BLOCK(PARTHE,NOMBLAY,1,'PARTHE',
     &                          IELMT,1,2,MESH)
!
      CALL BIEF_ALLVEC_IN_BLOCK(QSCL  ,NSICLA,1,'QSCL  ',IELMT,1,2,MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(QSCL_C,NSICLA,1,'QSCL_C',IELMT,1,2,MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(QSCLXC,NSICLA,1,'QSCLXC',IELMT,1,2,MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(QSCLYC,NSICLA,1,'QSCLYC',IELMT,1,2,MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(MUDB  ,NSICLA,1,'MUDB  ',IELMT,1,2,MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(F_MUDB,NSICLA,1,'F_MUDB',IELMT,1,2,MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(ZFCL_C,NSICLA,1,'ZFCL_C',IELMT,1,2,MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(EVCL_MB,NSICLA,1,'EVC_MB',IELMT,1,2,
     &     MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(EVCL_MS,NSICLA,1,'EVC_MS',IELMT,1,2,
     &     MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(CALFA_CL,NSICLA,1,'CALFA ',
     &     IELMT,1,2,MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(SALFA_CL,NSICLA,1,'SALFA ',
     &     IELMT,1,2,MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(QSCL_S,NSICLA,1,'QSCL_S',IELMT,1,2,MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(FLUDP ,NSICLA,1,'FLUDP ',IELMT,1,2,MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(FLUDPT,NSICLA,1,'FLUDPT',IELMT,1,2,MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(FLUER ,NSICLA,1,'FLUER ',IELMT,1,2,MESH)
      CALL BIEF_ALLVEC_IN_BLOCK(FLUERT,NSICLA,1,'FLUERT',IELMT,1,2,MESH)
!
      IF(SLIDE) THEN
        CALL BIEF_ALLVEC_IN_BLOCK(ZFCL_MS,NSICLA,1,
     &                            'ZFCLMS',IELMT,1,2,MESH)
      ELSE
        CALL BIEF_ALLVEC_IN_BLOCK(ZFCL_MS,NSICLA,1,
     &                            'ZFCLMS',    0,1,0,MESH)
      ENDIF
!
!     *************
!     VI - MATRICES
!     *************
!
!
      CALL BIEF_ALLMAT(MBOR ,'MBOR  ',IELBT,IELBT,CFGBOR,'Q','Q',MESH) ! SUSPENSION BOUNDRAY MATRIX
!
!
!     ******************
!     VII - OTHER ARRAYS
!     ******************
!
!     NTR SHOULD AT LEAST BE THE NUMBER OF VARIABLES IN VARSOR THAT WILL BE READ IN
!     VALIDA. HERE UP TO THE LAYER THICKNESSES
!
!     CV V6P2
!     NTR   = 27+(NOMBLAY+4)*NSICLA+NOMBLAY+NPRIV
      NTR   = 27+(NOMBLAY+4)*NSICLA+2*NOMBLAY+NPRIV
!
!     W1 NO LONGER USED (IS SENT TO CVDFTR BUT CVDFTR DOES NOTHING WITH IT)
      CALL BIEF_ALLVEC(1, W1 , 'W1    ', IELM0    , 1,1,MESH) ! WORK ARRAY
      CALL BIEF_ALLVEC(1, TE1, 'TE1   ', IELM0_SUB, 1,1,MESH) ! WORK ARRAY BY ELEMENT
      CALL BIEF_ALLVEC(1, TE2, 'TE2   ', IELM0_SUB, 1,1,MESH) ! WORK ARRAY BY ELEMENT
      CALL BIEF_ALLVEC(1, TE3, 'TE3   ', IELM0_SUB, 1,1,MESH) ! WORK ARRAY BY ELEMENT
!
      CALL ALLBLO(VARCL, 'VARCL ') ! CLANDESTINE VARIABLES
      CALL ALLBLO(PRIVE, 'PRIVE ') ! USER ARRAY
      CALL ALLBLO(TB   , 'TB    ') ! WORKING ARRAY
      CALL BIEF_ALLVEC_IN_BLOCK(TB   ,NTR   ,1,'T     ',IELMT,1,2,MESH)
!
      CALL BIEF_ALLVEC_IN_BLOCK(VARCL,NVARCL,1,'CL    ',IELMT,1,2,MESH)
      IF(NPRIV.GT.0) THEN
        CALL BIEF_ALLVEC_IN_BLOCK(PRIVE,MAX(NPRIV,4),
     &                            1,'PRIV  ',IELMT,1,2,MESH)
      ELSE
        CALL BIEF_ALLVEC_IN_BLOCK(PRIVE,4,1,'PRIV  ',0,1,0,MESH)
      ENDIF
!     TO AVOID WRITING NON-INITIALISED ARRAYS TO FILES
      CALL OS('X=0     ',X=PRIVE)
!
      ! ************ !
      ! VIII - ALIAS !
      ! ************ !
!
      T1   => TB%ADR( 1)%P ! WORK ARRAY
      T2   => TB%ADR( 2)%P ! WORK ARRAY
      T3   => TB%ADR( 3)%P ! WORK ARRAY
      T4   => TB%ADR( 4)%P ! WORK ARRAY
      T5   => TB%ADR( 5)%P ! WORK ARRAY
      T6   => TB%ADR( 6)%P ! WORK ARRAY
      T7   => TB%ADR( 7)%P ! WORK ARRAY
      T8   => TB%ADR( 8)%P ! WORK ARRAY
      T9   => TB%ADR( 9)%P ! WORK ARRAY
      T10  => TB%ADR(10)%P ! WORK ARRAY
      T11  => TB%ADR(11)%P ! WORK ARRAY
      T12  => TB%ADR(12)%P ! WORK ARRAY
      T13  => TB%ADR(13)%P ! WORK ARRAY
      T14  => TB%ADR(14)%P ! WORK ARRAY
!
!     **************************************************************
!     IX - ALLOCATES A BLOCK CONNECTING A VARIABLE NAME TO ITS ARRAY
!     **************************************************************
!
      CALL ALLBLO(VARSOR, 'VARSOR')
      CALL ADDBLO(VARSOR, U2D    )            ! 01
      CALL ADDBLO(VARSOR, V2D    )            ! 02
      CALL ADDBLO(VARSOR, HN    )             ! 03
      CALL ADDBLO(VARSOR, Z     )             ! 04
      CALL ADDBLO(VARSOR, ZF    )             ! 05
      CALL ADDBLO(VARSOR, Q     )             ! 06
      CALL ADDBLO(VARSOR, QU    )             ! 07
      CALL ADDBLO(VARSOR, QV    )             ! 08
      CALL ADDBLO(VARSOR, ZR    )             ! 09
      CALL ADDBLO(VARSOR, TOB   )             ! 10
      CALL ADDBLO(VARSOR, HW    )             ! 11
      CALL ADDBLO(VARSOR, TW    )             ! 12
      CALL ADDBLO(VARSOR, THETAW)             ! 13
      CALL ADDBLO(VARSOR, QS    )             ! 14
      CALL ADDBLO(VARSOR, QSX   )             ! 15
      CALL ADDBLO(VARSOR, QSY   )             ! 16
      CALL ADDBLO(VARSOR, CUMBE )             ! 17
      CALL ADDBLO(VARSOR, KS)                 ! 18
      CALL ADDBLO(VARSOR, MU)                 ! 19
      CALL ADDBLO(VARSOR, ACLADM)             ! 20
      CALL ADDBLO(VARSOR, UW  )               ! 21
      CALL ADDBLO(VARSOR, ZRL   )             ! 22
      CHECK_NVAR=22
!     RATIOS: FROM NVAR_RATIOS+1 TO NVAR_QSCL
!
      DO I = 1,NOMBLAY*NSAND
        CALL ADDBLO(VARSOR, RATIOS%ADR(I)%P)
      ENDDO
      CHECK_NVAR=CHECK_NVAR+NOMBLAY*NSAND
!
!     QSCL: FROM NVAR_QSCL+1 TO NVAR_QS_C
!
      DO I = 1, NSICLA
        CALL ADDBLO(VARSOR, QSCL%ADR(I)%P)
      ENDDO
      CHECK_NVAR=CHECK_NVAR+NSICLA
!
!     QS_C: FROM NVAR_QS_C+1 TO NVAR_QSXC
!
      CALL ADDBLO(VARSOR,QS_C)
      CHECK_NVAR=CHECK_NVAR+1
!
!     QSXC: FROM NVAR_QSXC+1 TO NVAR_QSYC
!
      CALL ADDBLO(VARSOR,QSXC)
      CHECK_NVAR=CHECK_NVAR+1
!
!     QSYC: FROM NVAR_QYSC+1 TO NVAR_QSCL_C
!
      CALL ADDBLO(VARSOR,QSYC)
      CHECK_NVAR=CHECK_NVAR+1
!
!     QSCL_C: FROM NVAR_QSCL_C+1 TO NVAR_LAYTHI
!
      DO I=1,NSICLA
        CALL ADDBLO(VARSOR,QSCL_C%ADR(I)%P)
      ENDDO
      CHECK_NVAR=CHECK_NVAR+NSICLA
!
!     LAYTHI: FROM NVAR_LAYTHI+1 TO NVAR_LAYCONC
!
      DO I=1,NOMBLAY
        CALL ADDBLO(VARSOR,LAYTHI%ADR(I)%P)
      ENDDO
      CHECK_NVAR=CHECK_NVAR+NOMBLAY
!
!     LAYCONC: FROM NVAR_LAYCONC+1 TO NVAR_NPRIV
!
      DO I=1,NOMBLAY
        CALL ADDBLO(VARSOR,LAYCONC%ADR(I)%P)
      ENDDO
      CHECK_NVAR=CHECK_NVAR+NOMBLAY
!
!     PRIVE: FROM NVAR_PRIV+1 TO NVAR_RATIOM
!
      DO I=1,MAX(4,NPRIV)
        CALL ADDBLO(VARSOR,PRIVE%ADR(I)%P)
      ENDDO
      CHECK_NVAR=CHECK_NVAR+MAX(4,NPRIV)
!
!     RATIOM: FROM NVAR_RATIOM+1 TO NVAR_MASS_S
!
      DO I = 1,NOMBLAY*NMUD
        CALL ADDBLO(VARSOR, RATIOM%ADR(I)%P)
      ENDDO
      CHECK_NVAR=CHECK_NVAR+NOMBLAY*NMUD
!
!     MASS_S: FROM NVAR_MASS_S+1 TO NVAR_MASS_M
!
      DO I = 1,NOMBLAY*NSAND
        CALL ADDBLO(VARSOR, MASS_S%ADR(I)%P)
      ENDDO
      CHECK_NVAR=CHECK_NVAR+NOMBLAY*NSAND
!
!     MASS_M: FROM NVAR_MASS_M+1 TO NVAR_MTRANS
!
      DO I = 1,NOMBLAY*NMUD
        CALL ADDBLO(VARSOR, MASS_M%ADR(I)%P)
      ENDDO!
      CHECK_NVAR=CHECK_NVAR+NOMBLAY*NMUD
!
!     MTRANS: FROM NVAR_MTRANS+1 TO NVAR_TOCEMUD
!
      DO I = 1,NOMBLAY
        CALL ADDBLO(VARSOR, MTRANSFER%ADR(I)%P)
      ENDDO!
      CHECK_NVAR=CHECK_NVAR+NOMBLAY
!
!     TOCEMUD: FROM NVAR_TOCEMUD+1 TO NVAR_PARTHE
!
      DO I = 1,NOMBLAY
        CALL ADDBLO(VARSOR, TOCEMUD%ADR(I)%P)
      ENDDO!
      CHECK_NVAR=CHECK_NVAR+NOMBLAY
!
!     PARTHE: FROM NVAR_PARTHE+1 TO NVAR_VARCL
!
      DO I = 1,NOMBLAY
        CALL ADDBLO(VARSOR, PARTHE%ADR(I)%P)
      ENDDO!
      CHECK_NVAR=CHECK_NVAR+NOMBLAY
!
!     VARCL: FROM NVAR_VARCL+1 TO NVAR_NADVAR
!
      IF(VARCL%N.GT.0) THEN
        DO I=1,VARCL%N
          CALL ADDBLO(VARSOR,VARCL%ADR(I)%P)
          SORLEO(NVAR_VARCL+I)=.TRUE.
        ENDDO
      ENDIF
      CHECK_NVAR=CHECK_NVAR+VARCL%N
!
!     BLOCK OF DIFFERENTIATED VARIABLES
!     ARRAYS AD1, AD2, ... MUST EXIST BUT WILL
!     ONLY BE INTIALISED BY THE AD USER SUBROUTINES AD_GET_TELEMAC2D
!
!     DIFFERENTIATED VARIABLES
!
!     NADVAR: FROM NVAR_NADVAR+1 TO NVAR
!
      IF( NADVAR.GT.0 ) THEN
        CALL ALLBLO(ADVAR ,'ADVAR ')
        CALL BIEF_ALLVEC_IN_BLOCK(ADVAR,NADVAR,1,'AD    ',IELMT,
     &                            1,2,MESH)
        DO I=1,NADVAR
          ADVAR%ADR(I)%P%R = 0.D0
          CALL AD_GET_GAIA(I,ADVAR%ADR(I)%P)
!
          IF( SORLEO(NVAR_ADVAR+I).OR.SORIMP(NVAR_ADVAR+I) )
     &      CALL ADDBLO(VARSOR,ADVAR%ADR(I)%P)
!
        ENDDO
      ENDIF
      CHECK_NVAR=CHECK_NVAR+NADVAR
!
      IF(CHECK_NVAR.NE.NVAR) THEN
        WRITE(LU,19) CHECK_NVAR,NVAR
        CALL PLANTE(1)
        STOP
      ENDIF
19    FORMAT(1X,'ERROR IN VARSOR: CHECK_NVAR IS',1X,I2,
     &     /,1X,'WHILE IT SHOULD BE EQUAL TO',1X,I2,
     &     /,'CHECK THE CORRESPONDENCE BETWEEN TEXTE/MNEMO AND VARSOR')
!
!-----------------------------------------------------------------------
! !JAJ #### IF REQUIRED, HERE WE CAN READ THE INPUT SECTIONS FILE
!      AND MODIFY NCP AND CTRLSC(1:NCP) ACCORDINGLY IN READ_SECTIONS
!
      IF(TRIM(GAI_FILES(GAISEC)%NAME).NE.'') THEN
        WRITE(LU,*)
     &   'POINT_GAIA: SECTIONS DEFINED IN THE SECTIONS INPUT FILE'
        CALL READ_SECTIONS_GAIA
      ELSE ! THE PREVIOUS WAY OF DOING THINGS
        IF(NCP.NE.0) THEN
          IF(NCP.NE.0) WRITE(LU,*)
     &      'POINT_GAIA: SECTIONS DEFINED IN THE PARAMETER FILE'
        ENDIF
      ENDIF
!
      WRITE(LU,22)
!
12    FORMAT(1X,///,21X,'*******************************',/,
     &21X,              '*     MEMORY ORGANISATION     *',/,
     &21X,              '*******************************',/)
22    FORMAT(1X,///,21X,'*************************************',/,
     &21X,              '*    END OF MEMORY ORGANIZATION:    *',/,
     &21X,              '*************************************',/)
!
!-----------------------------------------------------------------------
!
      RETURN
      END
