!                       *****************
                        SUBROUTINE CONVERTER
!                       *****************
     &(LOC_INPFILE,LOC_BNDFILE,
     & LOC_OUTFILE,LOC_OUTBNDFILE)
!
!***********************************************************************
! STBTEL   V6P1                                   11/07/2011
!***********************************************************************
!
!BRIEF    WRITE A FILE OF MED FORMAT WITH THE MESH OBJECT
!+        INFORMATIONS
!
!HISTORY  Y.AUDOUIN (EDF)
!+        11/07/2011
!+        V6P1
!+   CREATION OF THE FILE
!
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!| LOC_INPFILE        |-->| NAME OF THE INPUT FILE
!| LOC_LOGFILE        |-->| NAME OF THE LOG FILE
!| LOC_BNDFILE        |-->| NAME OF THE BOUNDARY FILE
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
      USE INTERFACE_HERMES
      USE DECLARATIONS_STBTEL, ONLY: INFILE,INFMT,BOUNDFILE,
     &                               OUTFILE,OUTFMT,OUTBNDFILE,DEBUG,
     &                               AUTO_PRECISION
!
      USE DECLARATIONS_SPECIAL
      IMPLICIT NONE
      ! LANGAE AND OUTPUT VALUE
!
!+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!
      ! NAME IN THE TEMPORARY FOLDER OF THE FILES :
      ! EQUAL ' ' IF FILE NOT AVAILABLE
      CHARACTER(LEN=MAXLENFILE), INTENT(IN) :: LOC_INPFILE
      CHARACTER(LEN=MAXLENFILE), INTENT(IN) :: LOC_BNDFILE
      CHARACTER(LEN=MAXLENFILE), INTENT(IN) :: LOC_OUTFILE
      CHARACTER(LEN=MAXLENFILE), INTENT(IN) :: LOC_OUTBNDFILE
!
!+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!
      INTEGER :: I,J
      INTEGER :: IERR
      CHARACTER(LEN=80) :: TITLE
      INTEGER :: INFID, OUTFID
      INTEGER :: DATE(6)
      INTEGER :: DATE2(3),TIME2(3)
      INTEGER :: TYP_ELEM, TYP_BND_ELEM
      INTEGER :: NPOIN,NELEM,NDP
      INTEGER :: NPLAN, NPTIR
      INTEGER :: NDIM
      DOUBLE PRECISION, ALLOCATABLE :: X(:),Y(:),Z(:)
      INTEGER :: NELEBD, NPTFR, NDP_BND
      INTEGER, ALLOCATABLE :: IKLE(:)
      INTEGER, ALLOCATABLE :: IKLES(:)
      INTEGER, ALLOCATABLE :: IKLE_BND(:)
      INTEGER, ALLOCATABLE :: KNOLG(:)
      INTEGER, ALLOCATABLE :: IPOBO(:)
      INTEGER, ALLOCATABLE :: LIHBOR(:)
      INTEGER, ALLOCATABLE :: LIUBOR(:)
      INTEGER, ALLOCATABLE :: LIVBOR(:)
      INTEGER, ALLOCATABLE :: LITBOR(:)
      INTEGER, ALLOCATABLE :: COLOR(:)
      DOUBLE PRECISION, ALLOCATABLE :: UBOR(:),VBOR(:)
      DOUBLE PRECISION, ALLOCATABLE :: HBOR(:),CHBORD(:)
      DOUBLE PRECISION, ALLOCATABLE :: TBOR(:),ATBOR(:)
      DOUBLE PRECISION, ALLOCATABLE :: BTBOR(:)
      INTEGER, ALLOCATABLE :: NBOR(:)
      INTEGER :: NTIMESTEP
      INTEGER :: NVAR
      DOUBLE PRECISION :: TIME
      CHARACTER(LEN=16), ALLOCATABLE :: VAR_NAME(:)
      CHARACTER(LEN=16), ALLOCATABLE :: VAR_UNIT(:)
      CHARACTER(LEN=32), ALLOCATABLE :: VAR_NAMES(:)
      CHARACTER(LEN=32) :: VARNAME
      DOUBLE PRECISION, ALLOCATABLE :: VAR_VALUE(:)
      INTEGER :: ITIME, IVAR
      INTEGER :: X_ORIG, Y_ORIG
      LOGICAL :: ISDOUBLE
!=======================================================================
!     READING MESH FILE AND FILLING MESH_OBJ
!=======================================================================
!
      IF(DEBUG) WRITE(LU,*) '---FILES INFORMATION---'
      IF(DEBUG) WRITE(LU,*) 'INPUT FILE        : ',INFILE
      IF(DEBUG) WRITE(LU,*) 'INPUT FORMAT      : ',INFMT
      IF(DEBUG) WRITE(LU,*) 'BOUNDARY FILE     : ',BOUNDFILE
      IF(DEBUG) WRITE(LU,*) 'OUTPUT FILE       : ',OUTFILE
      IF(DEBUG) WRITE(LU,*) 'OUTPUT FORMAT     : ',OUTFMT
      IF(DEBUG) WRITE(LU,*) 'OUT BOUNDARY FILE : ',OUTBNDFILE
!
!-----------------------------------------------------------------------
!

      CALL OPEN_MESH(INFMT,LOC_INPFILE,INFID,'READ     ',IERR)
      CALL CHECK_CALL(IERR,'CONVERTER:OPEN_MESH:IN')

      CALL GET_MESH_TITLE(INFMT,INFID,TITLE,IERR)
      CALL CHECK_CALL(IERR,'CONVERTER:GET_MESH_TITLE')
      CALL GET_MESH_DATE(INFMT,INFID,DATE,IERR)
      CALL CHECK_CALL(IERR,'CONVERTER:GET_MESH_DATE')

      CALL GET_MESH_DIMENSION(INFMT,INFID,NDIM,IERR)
      CALL CHECK_CALL(IERR,'CONVERTER:GET_MESH_DIMENSION')

      ! IDENTIFYING ELEMENTS TYPE
      IF(NDIM.EQ.2) THEN
        TYP_ELEM = TRIANGLE_ELT_TYPE
      ELSE
        TYP_ELEM = PRISM_ELT_TYPE
      ENDIF
      IF(INFMT(1:3).EQ.'MED') THEN
        TYP_BND_ELEM = EDGE_BND_ELT_TYPE
        NDP_BND = 2
        ! CHECKING IF WE HAVE ANY EDGES
        CALL GET_MESH_NELEM(INFMT,INFID,TYP_BND_ELEM,NELEM,IERR)
        IF(IERR.NE.0.OR.NELEM.EQ.0) THEN
          TYP_BND_ELEM = POINT_BND_ELT_TYPE
          NDP_BND = 1
        ENDIF
      ELSE
        TYP_BND_ELEM = POINT_BND_ELT_TYPE
        NDP_BND = 1
      ENDIF

      CALL GET_MESH_NPOIN(INFMT,INFID,TYP_ELEM,NPOIN,IERR)
      CALL CHECK_CALL(IERR,'CONVERTER:GET_MESH_NPOIN')
      CALL GET_MESH_NELEM(INFMT,INFID,TYP_ELEM,NELEM,IERR)
      CALL CHECK_CALL(IERR,'CONVERTER:GET_MESH_NELEM')
      CALL GET_MESH_NPOIN_PER_ELEMENT(INFMT,INFID,TYP_ELEM,NDP,IERR)
      CALL CHECK_CALL(IERR,'CONVERTER:GET_MESH_NDP')
      CALL GET_MESH_NPLAN(INFMT,INFID,NPLAN,IERR)
      CALL CHECK_CALL(IERR,'CONVERTER:GET_MESH_NPLAN')
      CALL GET_MESH_ORIG(INFMT,INFID,X_ORIG,Y_ORIG,IERR)
      CALL CHECK_CALL(IERR,'CONVERTER:GET_MESH_ORIG')

      ALLOCATE(X(NPOIN),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'X')
      ALLOCATE(Y(NPOIN),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'Y')
      CALL GET_MESH_COORD(INFMT,INFID,1,NDIM,NPOIN,X,IERR)
      CALL GET_MESH_COORD(INFMT,INFID,2,NDIM,NPOIN,Y,IERR)
      IF(NDIM.EQ.3) THEN
        ALLOCATE(Z(NPOIN),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'Z')
        ! IN SERAFIN FORMAT Z COORD ARE IN A VARIABLE OF THE FILE
        ! EITHER "COTE Z" OR "ELEVATION Z"
        ! WE TAKE THE VALUE OF THE VARIABLE AT TIME 0 FOR Z COORDINATES
        ! IF THEY ARE NOT IN THE FILE THE COORDINATES ARE SET TO ZERO
        IF(INFMT(1:7).EQ.'SERAFIN') THEN
          VARNAME = ' '
          VARNAME = 'ELEVATION Z'
          CALL GET_DATA_VALUE(INFMT,INFID,0,VARNAME,
     &                        Z,NPOIN,IERR)
          IF(IERR.NE.0) THEN
            VARNAME = ' '
            VARNAME = 'COTE Z'
            CALL GET_DATA_VALUE(INFMT,INFID,0,VARNAME,
     &                          Z,NPOIN,IERR)
            IF(IERR.NE.0) THEN
              WRITE(LU,*) "COULD NOT READ Z COORDINATES FROM FILE"//
     &            " NEITHER 'COTE Z' NOR 'ELEVATION Z' ARE IN THE FILE"
              Z = 0.D0
            ENDIF
          ENDIF

        ELSE
          CALL GET_MESH_COORD(INFMT,INFID,3,NDIM,NPOIN,Z,IERR)
        ENDIF
      ENDIF

      ALLOCATE(IKLE(NELEM*NDP),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'IKLE')
      CALL GET_MESH_CONNECTIVITY(INFMT,INFID,TYP_ELEM,
     &                           IKLE,NELEM,NDP,IERR)
      CALL CHECK_CALL(IERR,'CONVERTER:GET_MESH_CONNECTIVITY')

      CALL GET_MESH_NPTIR(INFMT,INFID,NPTIR,IERR)
      CALL CHECK_CALL(IERR,'CONVERTER:GET_MESH_NPTIR')

      IF (OUTFMT(1:8).EQ."SERAFIN ".AND.AUTO_PRECISION) THEN
        CALL CHECK_COORD_PRECISION(X,Y,IKLE,NELEM,NDP,NPOIN,ISDOUBLE)
        IF (OUTFMT(1:7).EQ."SERAFIN".AND.ISDOUBLE) THEN
          WRITE(LU,*) "THE OUTPUT FORMAT IS NOT ADEQUATE WITH THE"//
     &                " PRECISION OF THE COORDINATES THE FILE WILL"//
     &                " INSTEAD BE WRITTEN IN SERAFIND"
          OUTFMT = "SERAFIND"
        ENDIF
      ENDIF

      ALLOCATE(KNOLG(NPOIN),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'KNOLG')
      IF(NPTIR.GT.0) THEN
        CALL GET_MESH_L2G_NUMBERING(INFMT,INFID,KNOLG,NPOIN,IERR)
        CALL CHECK_CALL(IERR,'CONVERTER:GET_MESH_L2G_NUMBERING')
      ELSE
        KNOLG = 0
      ENDIF

      ALLOCATE(IPOBO(NPOIN),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'IPOBO')
      IPOBO = 0

      IF(BOUNDFILE(1:1).NE.' ') THEN
        CALL OPEN_BND(INFMT,LOC_BNDFILE,INFID,'READ     ',IERR)
        CALL CHECK_CALL(IERR,'CONVERT:OPEN_BND:IN')

        CALL GET_BND_NPOIN(INFMT,INFID,TYP_BND_ELEM,NPTFR,IERR)
        CALL CHECK_CALL(IERR,'CONVERT:GET_BND_NPOIN')
        CALL GET_BND_NELEM(INFMT,INFID,TYP_BND_ELEM,NELEBD,IERR)
        CALL CHECK_CALL(IERR,'CONVERT:GET_BND_NPOIN')

        CALL GET_BND_IPOBO(INFMT,INFID,NPOIN,NELEBD,TYP_BND_ELEM,
     &                     IPOBO,IERR)
        CALL CHECK_CALL(IERR,'CONVERT:GET_BND_IPOBO')

        ALLOCATE(NBOR(NPTFR),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'NBOR')
        CALL GET_BND_NUMBERING(INFMT,INFID,TYP_BND_ELEM,NPTFR,NBOR,IERR)
        CALL CHECK_CALL(IERR,'CONVERT:GET_BND_NUMBERING')

        ALLOCATE(IKLE_BND(NELEBD*NDP_BND),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'IKLE_BND')
        CALL GET_BND_CONNECTIVITY(INFMT,INFID,TYP_BND_ELEM,
     &                            NELEBD,NDP_BND,IKLE_BND,IERR)
        CALL CHECK_CALL(IERR,'CONVERT:GET_BND_CONNECTIVITY')

        ALLOCATE(LIHBOR(NPTFR),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'LIHBOR')
        ALLOCATE(LIUBOR(NPTFR),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'LIUBOR')
        ALLOCATE(LIVBOR(NPTFR),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'LIVBOR')
        ALLOCATE(LITBOR(NPTFR),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'LITBOR')
        ALLOCATE(HBOR(NPTFR),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'HBOR')
        ALLOCATE(UBOR(NPTFR),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'UBOR')
        ALLOCATE(VBOR(NPTFR),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'VBOR')
        ALLOCATE(TBOR(NPTFR),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'TBOR')
        ALLOCATE(ATBOR(NPTFR),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'ATBOR')
        ALLOCATE(BTBOR(NPTFR),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'BTBOR')
        ALLOCATE(CHBORD(NPTFR),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'CHBORD')
        ALLOCATE(COLOR(NPTFR),STAT=IERR)
        CALL CHECK_ALLOCATE(IERR,'COLOT')

        CALL GET_BND_VALUE(INFMT,INFID,TYP_BND_ELEM,NELEBD,
     &                     LIHBOR,LIUBOR, LIVBOR,HBOR,UBOR,VBOR,
     &                     CHBORD,.TRUE., LITBOR,TBOR,ATBOR,BTBOR,
     &                     NPTFR,IERR)
        CALL CHECK_CALL(IERR,'CONVERT:GET_BND_VALUE')

        CALL GET_BND_COLOR(INFMT,INFID,TYP_BND_ELEM,NELEBD,COLOR,IERR)
        CALL CHECK_CALL(IERR,'CONVERT:GET_BND_COLOR')

        CALL CLOSE_BND(INFMT,INFID,IERR)
        CALL CHECK_CALL(IERR,'CONVERT:CLOSE_BND:IN')
      ELSE
        NPTFR = 0
        NELEBD = 0
        IPOBO = 0
      ENDIF

      CALL GET_DATA_NTIMESTEP(INFMT,INFID,NTIMESTEP,IERR)
      CALL CHECK_CALL(IERR,'CONVERT:GET_DATA_NTIMESTEP')

      CALL GET_DATA_NVAR(INFMT,INFID,NVAR,IERR)
      CALL CHECK_CALL(IERR,'CONVERT:GET_DATA_NVAR')

      ALLOCATE(VAR_NAME(NVAR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'VAR_NAME')
      ALLOCATE(VAR_UNIT(NVAR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'VAR_UNIT')
      ALLOCATE(VAR_NAMES(NVAR),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'VAR_NAME')

      CALL GET_DATA_VAR_LIST(INFMT,INFID,NVAR,VAR_NAME,VAR_UNIT,IERR)
      CALL CHECK_CALL(IERR,'CONVERT:GET_DATA_VAR_LIST')
      DO I=1,NVAR
        VAR_NAMES(I)(1:16) =  VAR_NAME(I)
        VAR_NAMES(I)(17:32) = VAR_UNIT(I)
      ENDDO

      CALL OPEN_MESH(OUTFMT,LOC_OUTFILE,OUTFID,'WRITE    ',IERR)
      CALL CHECK_CALL(IERR,'CONVERTER:OPEN_MESH:OUT')

      IF(BOUNDFILE(1:1).NE.' ') THEN
        CALL OPEN_BND(OUTFMT,LOC_OUTBNDFILE,OUTFID,'WRITE    ',IERR)
        CALL CHECK_CALL(IERR,'CONVERTER:OPEN_BND:OUT')
      ENDIF

      CALL SET_HEADER(OUTFMT,OUTFID,TITLE,NVAR,VAR_NAMES,IERR)
      CALL CHECK_CALL(IERR,'CONVERTER:SET_HEADER')
      DEALLOCATE(VAR_NAMES)

      DATE2(1) = DATE(1)
      DATE2(2) = DATE(2)
      DATE2(3) = DATE(3)
      TIME2(1) = DATE(4)
      TIME2(2) = DATE(5)
      TIME2(3) = DATE(6)
      ALLOCATE(IKLES(NELEM*NDP),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'IKLES')
      DO I=1,NELEM
        DO J=1,NDP
          IKLES(I+(J-1)*NELEM) = IKLE((I-1)*NDP+J)
        ENDDO
      ENDDO


      IF(NDIM.EQ.2) THEN
        CALL SET_MESH(OUTFMT,OUTFID,NDIM,TYP_ELEM,NDP,NPTFR,NPTIR,
     &                NELEM,NPOIN,IKLES,IPOBO,KNOLG,X,Y,NPLAN,
     &                DATE2,TIME2,X_ORIG,Y_ORIG,IERR)
      ELSE
        CALL SET_MESH(OUTFMT,OUTFID,NDIM,TYP_ELEM,NDP,NPTFR,NPTIR,
     &                NELEM,NPOIN,IKLES,IPOBO,KNOLG,X,Y,NPLAN,
     &                DATE2,TIME2,X_ORIG,Y_ORIG,IERR,Z)
      ENDIF
      CALL CHECK_CALL(IERR,'CONVERTER:SET_MESH')

      DEALLOCATE(IKLE)
      DEALLOCATE(IKLES)
      DEALLOCATE(IPOBO)
      DEALLOCATE(KNOLG)
      DEALLOCATE(X)
      DEALLOCATE(Y)

      IF(BOUNDFILE(1:1).NE.' ') THEN
        ! CHANGING BOUNDRAY TYPE TO POINT IN SERAFIN
        IF (OUTFMT(1:7).EQ.'SERAFIN') THEN
          DEALLOCATE(IKLE_BND)
          ALLOCATE(IKLE_BND(NPTFR),STAT=IERR)
          CALL CHECK_ALLOCATE(IERR,'IKLE_BND')

          IKLE_BND = NBOR
          TYP_BND_ELEM = POINT_BND_ELT_TYPE
          NDP_BND = 1
        ENDIF
        CALL SET_BND(OUTFMT,OUTFID,TYP_BND_ELEM,NELEBD,NDP_BND,
     &               IKLE_BND,NPTFR,LIHBOR,LIUBOR,LIVBOR,HBOR,UBOR,
     &               VBOR,CHBORD,LITBOR,TBOR,ATBOR,BTBOR,COLOR,IERR)
        CALL CHECK_CALL(IERR,'CONVERTER:SET_BND')
        DEALLOCATE(IKLE_BND)
        DEALLOCATE(LIHBOR)
        DEALLOCATE(LIUBOR)
        DEALLOCATE(LIVBOR)
        DEALLOCATE(HBOR)
        DEALLOCATE(UBOR)
        DEALLOCATE(VBOR)
        DEALLOCATE(CHBORD)
        DEALLOCATE(TBOR)
        DEALLOCATE(ATBOR)
        DEALLOCATE(BTBOR)
        DEALLOCATE(COLOR)
      ENDIF

      ALLOCATE(VAR_VALUE(NPOIN),STAT=IERR)
      CALL CHECK_ALLOCATE(IERR,'VAR_VALUES')
      DO ITIME=1,NTIMESTEP
        CALL GET_DATA_TIME(INFMT,INFID,ITIME-1,TIME,IERR)
        CALL CHECK_CALL(IERR,'CONVERTER:GET_DATA_TIME')
        DO IVAR=1,NVAR
          CALL GET_DATA_VALUE(INFMT,INFID,ITIME-1,VAR_NAME(IVAR),
     &                        VAR_VALUE,NPOIN,IERR)
          CALL CHECK_CALL(IERR,'CONVERTER:GET_DATA_VALUE')

          VARNAME(1:16) = VAR_NAME(IVAR)
          VARNAME(17:32) = VAR_UNIT(IVAR)
          CALL ADD_DATA(OUTFMT,OUTFID,VARNAME,TIME,ITIME-1,
     &                  IVAR==1,VAR_VALUE,NPOIN,IERR)
          CALL CHECK_CALL(IERR,'CONVERTER:ADD_DATA')
        ENDDO
      ENDDO
      DEALLOCATE(VAR_VALUE)

      IF(BOUNDFILE(1:1).NE.' ') THEN
        CALL CLOSE_BND(OUTFMT,OUTFID,IERR)
        CALL CHECK_CALL(IERR,'CONVERTER:CLOSE_BND:OUT')
      ENDIF
      CALL CLOSE_MESH(INFMT,INFID,IERR)
      CALL CHECK_CALL(IERR,'CONVERTER:CLOSE_MESH:IN')
      CALL CLOSE_MESH(OUTFMT,OUTFID,IERR)
      CALL CHECK_CALL(IERR,'CONVERTER:CLOSE_MESH:OUT')

      END
